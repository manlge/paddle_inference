/* automatically generated by rust-bindgen 0.66.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDIO_H: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_LIBIO_H: u32 = 1;
pub const _BITS_G_CONFIG_H: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_marker> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sbuf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pos) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type PD_Bool = i8;
pub type PD_PrecisionType = i32;
pub const PD_PRECISION_FLOAT32: _bindgen_ty_1 = 0;
pub const PD_PRECISION_INT8: _bindgen_ty_1 = 1;
pub const PD_PRECISION_HALF: _bindgen_ty_1 = 2;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub type PD_PlaceType = i32;
pub const PD_PLACE_UNK: _bindgen_ty_2 = -1;
pub const PD_PLACE_CPU: _bindgen_ty_2 = 0;
pub const PD_PLACE_GPU: _bindgen_ty_2 = 1;
pub const PD_PLACE_XPU: _bindgen_ty_2 = 2;
pub type _bindgen_ty_2 = ::std::os::raw::c_int;
pub type PD_DataType = i32;
pub const PD_DATA_UNK: _bindgen_ty_3 = -1;
pub const PD_DATA_FLOAT32: _bindgen_ty_3 = 0;
pub const PD_DATA_INT32: _bindgen_ty_3 = 1;
pub const PD_DATA_INT64: _bindgen_ty_3 = 2;
pub const PD_DATA_UINT8: _bindgen_ty_3 = 3;
pub const PD_DATA_INT8: _bindgen_ty_3 = 4;
pub type _bindgen_ty_3 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PD_OneDimArrayInt32 {
    pub size: usize,
    pub data: *mut i32,
}
#[test]
fn bindgen_test_layout_PD_OneDimArrayInt32() {
    const UNINIT: ::std::mem::MaybeUninit<PD_OneDimArrayInt32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PD_OneDimArrayInt32>(),
        16usize,
        concat!("Size of: ", stringify!(PD_OneDimArrayInt32))
    );
    assert_eq!(
        ::std::mem::align_of::<PD_OneDimArrayInt32>(),
        8usize,
        concat!("Alignment of ", stringify!(PD_OneDimArrayInt32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PD_OneDimArrayInt32),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PD_OneDimArrayInt32),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PD_OneDimArraySize {
    pub size: usize,
    pub data: *mut usize,
}
#[test]
fn bindgen_test_layout_PD_OneDimArraySize() {
    const UNINIT: ::std::mem::MaybeUninit<PD_OneDimArraySize> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PD_OneDimArraySize>(),
        16usize,
        concat!("Size of: ", stringify!(PD_OneDimArraySize))
    );
    assert_eq!(
        ::std::mem::align_of::<PD_OneDimArraySize>(),
        8usize,
        concat!("Alignment of ", stringify!(PD_OneDimArraySize))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PD_OneDimArraySize),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PD_OneDimArraySize),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PD_OneDimArrayCstr {
    pub size: usize,
    pub data: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PD_OneDimArrayCstr() {
    const UNINIT: ::std::mem::MaybeUninit<PD_OneDimArrayCstr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PD_OneDimArrayCstr>(),
        16usize,
        concat!("Size of: ", stringify!(PD_OneDimArrayCstr))
    );
    assert_eq!(
        ::std::mem::align_of::<PD_OneDimArrayCstr>(),
        8usize,
        concat!("Alignment of ", stringify!(PD_OneDimArrayCstr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PD_OneDimArrayCstr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PD_OneDimArrayCstr),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PD_Cstr {
    pub size: usize,
    pub data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PD_Cstr() {
    const UNINIT: ::std::mem::MaybeUninit<PD_Cstr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PD_Cstr>(),
        16usize,
        concat!("Size of: ", stringify!(PD_Cstr))
    );
    assert_eq!(
        ::std::mem::align_of::<PD_Cstr>(),
        8usize,
        concat!("Alignment of ", stringify!(PD_Cstr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PD_Cstr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PD_Cstr),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PD_TwoDimArraySize {
    pub size: usize,
    pub data: *mut *mut PD_OneDimArraySize,
}
#[test]
fn bindgen_test_layout_PD_TwoDimArraySize() {
    const UNINIT: ::std::mem::MaybeUninit<PD_TwoDimArraySize> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PD_TwoDimArraySize>(),
        16usize,
        concat!("Size of: ", stringify!(PD_TwoDimArraySize))
    );
    assert_eq!(
        ::std::mem::align_of::<PD_TwoDimArraySize>(),
        8usize,
        concat!("Alignment of ", stringify!(PD_TwoDimArraySize))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PD_TwoDimArraySize),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PD_TwoDimArraySize),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PD_Config {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "\n \\brief Create a paddle config\n\n \\return new config.\n"]
    pub fn PD_ConfigCreate() -> *mut PD_Config;
}
extern "C" {
    #[doc = "\n \\brief Destroy the paddle config\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigDestroy(pd_config: *mut PD_Config);
}
extern "C" {
    #[doc = "\n \\brief Set the combined model with two specific pathes for program and\n parameters.\n\n \\param[in] pd_onfig config\n \\param[in] prog_file_path model file path of the combined model.\n \\param[in] params_file_path params file path of the combined model.\n"]
    pub fn PD_ConfigSetModel(
        pd_config: *mut PD_Config,
        prog_file_path: *const ::std::os::raw::c_char,
        params_file_path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\n \\brief Set the model file path of a combined model.\n\n \\param[in] pd_onfig config\n \\param[in] prog_file_path model file path.\n"]
    pub fn PD_ConfigSetProgFile(
        pd_config: *mut PD_Config,
        prog_file_path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\n \\brief Set the params file path of a combined model.\n\n \\param[in] pd_onfig config\n \\param[in] params_file_path params file path.\n"]
    pub fn PD_ConfigSetParamsFile(
        pd_config: *mut PD_Config,
        params_file_path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\n \\brief Set the path of optimization cache directory.\n \\param[in] pd_onfig config\n \\param[in] opt_cache_dir the path of optimization cache directory.\n"]
    pub fn PD_ConfigSetOptimCacheDir(
        pd_config: *mut PD_Config,
        opt_cache_dir: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\n \\brief Set the no-combined model dir path.\n \\param[in] pd_onfig config\n \\param[in] model_dir model dir path.\n"]
    pub fn PD_ConfigSetModelDir(
        pd_config: *mut PD_Config,
        model_dir: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\n \\brief Get the model directory path.\n\n \\param[in] pd_onfig config\n \\return The model directory path.\n"]
    pub fn PD_ConfigGetModelDir(pd_config: *mut PD_Config) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\n \\brief Get the program file path.\n\n \\param[in] pd_onfig config\n \\return The program file path.\n"]
    pub fn PD_ConfigGetProgFile(pd_config: *mut PD_Config) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\n \\brief Get the params file path.\n\n \\param[in] pd_onfig config\n \\return The params file path.\n"]
    pub fn PD_ConfigGetParamsFile(pd_config: *mut PD_Config) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\n \\brief Turn off FC Padding.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigDisableFCPadding(pd_config: *mut PD_Config);
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether fc padding is used.\n\n \\param[in] pd_onfig config\n \\return Whether fc padding is used.\n"]
    pub fn PD_ConfigUseFcPadding(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Turn on GPU.\n\n \\param[in] pd_onfig config\n \\param[in] memory_pool_init_size_mb initial size of the GPU memory pool in\n MB.\n \\param[in] device_id device_id the GPU card to use.\n"]
    pub fn PD_ConfigEnableUseGpu(
        pd_config: *mut PD_Config,
        memory_pool_init_size_mb: u64,
        device_id: i32,
    );
}
extern "C" {
    #[doc = "\n \\brief Turn off GPU.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigDisableGpu(pd_config: *mut PD_Config);
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether the GPU is turned on.\n\n \\brief Turn off GPU.\n \\return Whether the GPU is turned on.\n"]
    pub fn PD_ConfigUseGpu(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Turn on ONNXRuntime.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigEnableONNXRuntime(pd_config: *mut PD_Config);
}
extern "C" {
    #[doc = "\n \\brief Turn off ONNXRuntime.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigDisableONNXRuntime(pd_config: *mut PD_Config);
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether the ONNXRutnime is turned on.\n\n \\return Whether the ONNXRuntime is turned on.\n"]
    pub fn PD_ConfigONNXRuntimeEnabled(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Turn on ONNXRuntime Optimization.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigEnableORTOptimization(pd_config: *mut PD_Config);
}
extern "C" {
    #[doc = "\n \\brief Turn on XPU.\n\n \\param[in] pd_onfig config\n \\param l3_workspace_size The size of the video memory allocated by the l3\n         cache, the maximum is 16M.\n \\param locked Whether the allocated L3 cache can be locked. If false,\n       it means that the L3 cache is not locked, and the allocated L3\n       cache can be shared by multiple models, and multiple models\n       sharing the L3 cache will be executed sequentially on the card.\n \\param autotune Whether to autotune the conv operator in the model. If\n       true, when the conv operator of a certain dimension is executed\n       for the first time, it will automatically search for a better\n       algorithm to improve the performance of subsequent conv operators\n       of the same dimension.\n \\param autotune_file Specify the path of the autotune file. If\n       autotune_file is specified, the algorithm specified in the\n       file will be used and autotune will not be performed again.\n \\param precision Calculation accuracy of multi_encoder\n \\param adaptive_seqlen Is the input of multi_encoder variable length\n"]
    pub fn PD_ConfigEnableXpu(
        pd_config: *mut PD_Config,
        l3_workspace_size: i32,
        locked: PD_Bool,
        autotune: PD_Bool,
        autotune_file: *const ::std::os::raw::c_char,
        precision: *const ::std::os::raw::c_char,
        adaptive_seqlen: PD_Bool,
    );
}
extern "C" {
    #[doc = "\n \\brief Turn on NPU.\n\n \\param[in] pd_onfig config\n \\param[in] device_id device_id the NPU card to use.\n"]
    pub fn PD_ConfigEnableNpu(pd_config: *mut PD_Config, device_id: i32);
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether the XPU is turned on.\n\n \\param[in] pd_onfig config\n \\return Whether the XPU is turned on.\n"]
    pub fn PD_ConfigUseXpu(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether the NPU is turned on.\n\n \\param[in] pd_onfig config\n \\return Whether the NPU is turned on.\n"]
    pub fn PD_ConfigUseNpu(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Get the GPU device id.\n\n \\param[in] pd_onfig config\n \\return The GPU device id.\n"]
    pub fn PD_ConfigGpuDeviceId(pd_config: *mut PD_Config) -> i32;
}
extern "C" {
    #[doc = "\n \\brief Get the XPU device id.\n\n \\param[in] pd_onfig config\n \\return The XPU device id.\n"]
    pub fn PD_ConfigXpuDeviceId(pd_config: *mut PD_Config) -> i32;
}
extern "C" {
    #[doc = "\n \\brief Get the NPU device id.\n\n \\param[in] pd_onfig config\n \\return The NPU device id.\n"]
    pub fn PD_ConfigNpuDeviceId(pd_config: *mut PD_Config) -> i32;
}
extern "C" {
    #[doc = "\n \\brief Get the initial size in MB of the GPU memory pool.\n\n \\param[in] pd_onfig config\n \\return The initial size in MB of the GPU memory pool.\n"]
    pub fn PD_ConfigMemoryPoolInitSizeMb(pd_config: *mut PD_Config) -> i32;
}
extern "C" {
    #[doc = "\n \\brief Get the proportion of the initial memory pool size compared to the\n device.\n\n \\param[in] pd_onfig config\n \\return The proportion of the initial memory pool size.\n"]
    pub fn PD_ConfigFractionOfGpuMemoryForPool(pd_config: *mut PD_Config) -> f32;
}
extern "C" {
    #[doc = "\n \\brief Turn on CUDNN.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigEnableCudnn(pd_config: *mut PD_Config);
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether to use CUDNN.\n\n \\param[in] pd_onfig config\n \\return Whether to use CUDNN.\n"]
    pub fn PD_ConfigCudnnEnabled(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Control whether to perform IR graph optimization.\n If turned off, the AnalysisConfig will act just like a NativeConfig.\n\n \\param[in] pd_onfig config\n \\param[in] x Whether the ir graph optimization is actived.\n"]
    pub fn PD_ConfigSwitchIrOptim(pd_config: *mut PD_Config, x: PD_Bool);
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether the ir graph optimization is\n actived.\n\n \\param[in] pd_onfig config\n \\return Whether to use ir graph optimization.\n"]
    pub fn PD_ConfigIrOptim(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Turn on the TensorRT engine.\n The TensorRT engine will accelerate some subgraphes in the original Fluid\n computation graph. In some models such as resnet50, GoogleNet and so on,\n it gains significant performance acceleration.\n\n \\param[in] pd_onfig config\n \\param[in] workspace_size The memory size(in byte) used for TensorRT\n workspace.\n \\param[in] max_batch_size The maximum batch size of this prediction task,\n better set as small as possible for less performance loss.\n \\param[in] min_subgrpah_size The minimum TensorRT subgraph size needed, if a\n subgraph is smaller than this, it will not be transferred to TensorRT\n engine.\n \\param[in] precision The precision used in TensorRT.\n \\param[in] use_static Serialize optimization information to disk for\n reusing.\n \\param[in] use_calib_mode Use TRT int8 calibration(post training\n quantization).\n"]
    pub fn PD_ConfigEnableTensorRtEngine(
        pd_config: *mut PD_Config,
        workspace_size: i32,
        max_batch_size: i32,
        min_subgraph_size: i32,
        precision: PD_PrecisionType,
        use_static: PD_Bool,
        use_calib_mode: PD_Bool,
    );
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether the TensorRT engine is used.\n\n \\param[in] pd_onfig config\n \\return Whether the TensorRT engine is used.\n"]
    pub fn PD_ConfigTensorRtEngineEnabled(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Set min, max, opt shape for TensorRT Dynamic shape mode.\n\n \\param[in] pd_onfig config\n \\param[in] tensor_num The number of the subgraph input.\n \\param[in] tensor_name The name of every subgraph input.\n \\param[in] shapes_num The shape size of every subgraph input.\n \\param[in] min_shape The min input shape of every subgraph input.\n \\param[in] max_shape The max input shape of every subgraph input.\n \\param[in] optim_shape The opt input shape of every subgraph input.\n \\param[in] disable_trt_plugin_fp16 Setting this parameter to true means that\n TRT plugin will not run fp16.\n"]
    pub fn PD_ConfigSetTrtDynamicShapeInfo(
        pd_config: *mut PD_Config,
        tensor_num: usize,
        tensor_name: *mut *const ::std::os::raw::c_char,
        shapes_num: *mut usize,
        min_shape: *mut *mut i32,
        max_shape: *mut *mut i32,
        optim_shape: *mut *mut i32,
        disable_trt_plugin_fp16: PD_Bool,
    );
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether the trt dynamic_shape is used.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigTensorRtDynamicShapeEnabled(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Enable tuned tensorrt dynamic shape.\n\n \\param[in] pd_onfig config\n \\param[in] shape_range_info_path the path to shape_info file got in\n CollectShapeInfo mode.\n \\param[in] allow_build_at_runtime allow build trt engine at runtime.\n"]
    pub fn PD_ConfigEnableTunedTensorRtDynamicShape(
        pd_config: *mut PD_Config,
        shape_range_info_path: *const ::std::os::raw::c_char,
        allow_build_at_runtime: PD_Bool,
    );
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether to use tuned tensorrt dynamic\n shape.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigTunedTensorRtDynamicShape(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether to allow building trt engine at\n runtime.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigTrtAllowBuildAtRuntime(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Collect shape info of all tensors in compute graph.\n\n \\param[in] pd_onfig config\n \\param[in] shape_range_info_path the path to save shape info.\n"]
    pub fn PD_ConfigCollectShapeRangeInfo(
        pd_config: *mut PD_Config,
        shape_range_info_path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\n \\brief the shape info path in CollectShapeInfo mode.\n Attention, Please release the string manually.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigShapeRangeInfoPath(pd_config: *mut PD_Config) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether to collect shape info.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigShapeRangeInfoCollected(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Prevent ops running in Paddle-TRT\n NOTE: just experimental, not an official stable API, easy to be broken.\n\n \\param[in] pd_onfig config\n \\param[in] ops_num ops number\n \\param[in] ops_name ops name\n"]
    pub fn PD_ConfigDisableTensorRtOPs(
        pd_config: *mut PD_Config,
        ops_num: usize,
        ops_name: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\n \\brief Replace some TensorRT plugins to TensorRT OSS(\n https://github.com/NVIDIA/TensorRT), with which some models's inference\n may be more high-performance. Libnvinfer_plugin.so greater than\n V7.2.1 is needed.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigEnableTensorRtOSS(pd_config: *mut PD_Config);
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether to use the TensorRT OSS.\n\n \\param[in] pd_onfig config\n \\return Whether to use the TensorRT OSS.\n"]
    pub fn PD_ConfigTensorRtOssEnabled(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Enable TensorRT DLA\n\n \\param[in] pd_onfig config\n \\param[in] dla_core ID of DLACore, which should be 0, 1,\n        ..., IBuilder.getNbDLACores() - 1\n"]
    pub fn PD_ConfigEnableTensorRtDla(pd_config: *mut PD_Config, dla_core: i32);
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether to use the TensorRT DLA.\n\n \\param[in] pd_onfig config\n \\return Whether to use the TensorRT DLA.\n"]
    pub fn PD_ConfigTensorRtDlaEnabled(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Turn on the usage of Lite sub-graph engine.\n\n \\param[in] pd_onfig config\n \\param[in] precision Precion used in Lite sub-graph engine.\n \\param[in] zero_copy whether use zero copy.\n \\param[in] passes_filter_num The number of passes used in Lite sub-graph\n engine.\n \\param[in] passes_filter The name of passes used in Lite sub-graph engine.\n \\param[in] ops_filter_num The number of operators not supported by Lite.\n \\param[in] ops_filter The name of operators not supported by Lite.\n"]
    pub fn PD_ConfigEnableLiteEngine(
        pd_config: *mut PD_Config,
        precision: PD_PrecisionType,
        zero_copy: PD_Bool,
        passes_filter_num: usize,
        passes_filter: *mut *const ::std::os::raw::c_char,
        ops_filter_num: usize,
        ops_filter: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\n \\brief A boolean state indicating whether the Lite sub-graph engine is\n used.\n\n \\param[in] pd_onfig config\n \\return Whether the Lite sub-graph engine is used.\n"]
    pub fn PD_ConfigLiteEngineEnabled(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Control whether to debug IR graph analysis phase.\n This will generate DOT files for visualizing the computation graph after\n each analysis pass applied.\n\n \\param[in] pd_onfig config\n \\param[in] x whether to debug IR graph analysis phase.\n"]
    pub fn PD_ConfigSwitchIrDebug(pd_config: *mut PD_Config, x: PD_Bool);
}
extern "C" {
    #[doc = "\n \\brief Turn on MKLDNN.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigEnableMKLDNN(pd_config: *mut PD_Config);
}
extern "C" {
    #[doc = "\n \\brief Set the cache capacity of different input shapes for MKLDNN.\n Default value 0 means not caching any shape.\n Please see MKL-DNN Data Caching Design Document:\n https://github.com/PaddlePaddle/FluidDoc/blob/develop/doc/fluid/design/mkldnn/caching/caching.md\n\n \\param[in] pd_onfig config\n \\param[in] capacity The cache capacity.\n"]
    pub fn PD_ConfigSetMkldnnCacheCapacity(pd_config: *mut PD_Config, capacity: i32);
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether to use the MKLDNN.\n\n \\param[in] pd_onfig config\n \\return Whether to use the MKLDNN.\n"]
    pub fn PD_ConfigMkldnnEnabled(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Set the number of cpu math library threads.\n\n \\param[in] pd_onfig config\n \\param cpu_math_library_num_threads The number of cpu math library\n threads.\n"]
    pub fn PD_ConfigSetCpuMathLibraryNumThreads(
        pd_config: *mut PD_Config,
        cpu_math_library_num_threads: i32,
    );
}
extern "C" {
    #[doc = "\n \\brief An int state telling how many threads are used in the CPU math\n library.\n\n \\param[in] pd_onfig config\n \\return The number of threads used in the CPU math library.\n"]
    pub fn PD_ConfigGetCpuMathLibraryNumThreads(pd_config: *mut PD_Config) -> i32;
}
extern "C" {
    #[doc = "\n \\brief Specify the operator type list to use MKLDNN acceleration.\n\n \\param[in] pd_onfig config\n \\param[in] ops_num The number of operator type list.\n \\param[in] op_list The name of operator type list.\n"]
    pub fn PD_ConfigSetMkldnnOp(
        pd_config: *mut PD_Config,
        ops_num: usize,
        op_list: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\n \\brief Turn on MKLDNN quantization.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigEnableMkldnnQuantizer(pd_config: *mut PD_Config);
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether the MKLDNN quantization is enabled.\n\n \\param[in] pd_onfig config\n \\return Whether the MKLDNN quantization is enabled.\n"]
    pub fn PD_ConfigMkldnnQuantizerEnabled(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Turn on MKLDNN bfloat16.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigEnableMkldnnBfloat16(pd_config: *mut PD_Config);
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether to use the MKLDNN Bfloat16.\n\n \\param[in] pd_onfig config\n \\return Whether to use the MKLDNN Bfloat16.\n"]
    pub fn PD_ConfigMkldnnBfloat16Enabled(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = " \\brief Specify the operator type list to use Bfloat16 acceleration.\n\n \\param[in] pd_onfig config\n \\param[in] ops_num The number of operator type list.\n \\param[in] op_list The name of operator type list.\n"]
    pub fn PD_ConfigSetBfloat16Op(
        pd_config: *mut PD_Config,
        ops_num: usize,
        op_list: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\n \\brief Enable the GPU multi-computing stream feature.\n NOTE: The current behavior of this interface is to bind the computation\n stream to the thread, and this behavior may be changed in the future.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigEnableGpuMultiStream(pd_config: *mut PD_Config);
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether the thread local CUDA stream is\n enabled.\n\n \\param[in] pd_onfig config\n \\return Whether the thread local CUDA stream is enabled.\n"]
    pub fn PD_ConfigThreadLocalStreamEnabled(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Specify the memory buffer of program and parameter.\n Used when model and params are loaded directly from memory.\n\n \\param[in] pd_onfig config\n \\param[in] prog_buffer The memory buffer of program.\n \\param[in] prog_buffer_size The size of the model data.\n \\param[in] params_buffer The memory buffer of the combined parameters file.\n \\param[in] params_buffer_size The size of the combined parameters data.\n"]
    pub fn PD_ConfigSetModelBuffer(
        pd_config: *mut PD_Config,
        prog_buffer: *const ::std::os::raw::c_char,
        prog_buffer_size: usize,
        params_buffer: *const ::std::os::raw::c_char,
        params_buffer_size: usize,
    );
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether the model is set from the CPU\n memory.\n\n \\param[in] pd_onfig config\n \\return Whether model and params are loaded directly from memory.\n"]
    pub fn PD_ConfigModelFromMemory(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Turn on memory optimize\n NOTE still in development.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigEnableMemoryOptim(pd_config: *mut PD_Config, x: PD_Bool);
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether the memory optimization is\n activated.\n\n \\param[in] pd_onfig config\n \\return Whether the memory optimization is activated.\n"]
    pub fn PD_ConfigMemoryOptimEnabled(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Turn on profiling report.\n If not turned on, no profiling report will be generated.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigEnableProfile(pd_config: *mut PD_Config);
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether the profiler is activated.\n\n \\param[in] pd_onfig config\n \\return bool Whether the profiler is activated.\n"]
    pub fn PD_ConfigProfileEnabled(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Mute all logs in Paddle inference.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigDisableGlogInfo(pd_config: *mut PD_Config);
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether logs in Paddle inference are muted.\n\n \\param[in] pd_onfig config\n \\return Whether logs in Paddle inference are muted.\n"]
    pub fn PD_ConfigGlogInfoDisabled(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Set the Config to be invalid.\n This is to ensure that an Config can only be used in one\n Predictor.\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigSetInvalid(pd_config: *mut PD_Config);
}
extern "C" {
    #[doc = "\n \\brief A boolean state telling whether the Config is valid.\n\n \\param[in] pd_onfig config\n \\return Whether the Config is valid.\n"]
    pub fn PD_ConfigIsValid(pd_config: *mut PD_Config) -> PD_Bool;
}
extern "C" {
    #[doc = "\n \\brief Partially release the memory\n\n \\param[in] pd_onfig config\n"]
    pub fn PD_ConfigPartiallyRelease(pd_config: *mut PD_Config);
}
extern "C" {
    #[doc = "\n \\brief Delete all passes that has a certain type 'pass'.\n\n \\param[in] pass the certain pass type to be deleted.\n"]
    pub fn PD_ConfigDeletePass(pd_config: *mut PD_Config, pass: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "\n \\brief  Insert a pass to a specific position\n\n \\param[in] idx the position to insert.\n \\param[in] pass the new pass.\n"]
    pub fn PD_ConfigInsertPass(
        pd_config: *mut PD_Config,
        idx: usize,
        pass: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\n \\brief Append a pass to the end of the passes\n\n \\param[in] pass the new pass.\n"]
    pub fn PD_ConfigAppendPass(pd_config: *mut PD_Config, pass: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "\n \\brief Get information of passes.\n\n \\return Return list of the passes.\n"]
    pub fn PD_ConfigAllPasses(pd_config: *mut PD_Config) -> *mut PD_OneDimArrayCstr;
}
extern "C" {
    #[doc = "\n \\brief Get information of config.\n Attention, Please release the string manually.\n\n \\return Return config info.\n"]
    pub fn PD_ConfigSummary(pd_config: *mut PD_Config) -> *mut PD_Cstr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PD_Predictor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PD_Tensor {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "\n \\brief Create a new Predictor\n\n \\param[in] Config config\n \\return new predicor.\n"]
    pub fn PD_PredictorCreate(pd_config: *mut PD_Config) -> *mut PD_Predictor;
}
extern "C" {
    #[doc = "\n \\brief Clone a new Predictor\n\n \\param[in] pd_predictor predictor\n \\return new predictor.\n"]
    pub fn PD_PredictorClone(pd_predictor: *mut PD_Predictor) -> *mut PD_Predictor;
}
extern "C" {
    #[doc = "\n \\brief Get the input names\n\n \\param[in] pd_predictor predictor\n \\return input names\n"]
    pub fn PD_PredictorGetInputNames(pd_predictor: *mut PD_Predictor) -> *mut PD_OneDimArrayCstr;
}
extern "C" {
    #[doc = "\n \\brief Get the output names\n\n \\param[in] pd_predictor predictor\n \\return output names\n"]
    pub fn PD_PredictorGetOutputNames(pd_predictor: *mut PD_Predictor) -> *mut PD_OneDimArrayCstr;
}
extern "C" {
    #[doc = "\n \\brief Get the input number\n\n \\param[in] pd_predictor predictor\n \\return input number\n"]
    pub fn PD_PredictorGetInputNum(pd_predictor: *mut PD_Predictor) -> usize;
}
extern "C" {
    #[doc = "\n \\brief Get the output number\n\n \\param[in] pd_predictor predictor\n \\return output number\n"]
    pub fn PD_PredictorGetOutputNum(pd_predictor: *mut PD_Predictor) -> usize;
}
extern "C" {
    #[doc = "\n \\brief Get the Input Tensor object\n\n \\param[in] pd_predictor predictor\n \\param[in] name input name\n \\return input tensor\n"]
    pub fn PD_PredictorGetInputHandle(
        pd_predictor: *mut PD_Predictor,
        name: *const ::std::os::raw::c_char,
    ) -> *mut PD_Tensor;
}
extern "C" {
    #[doc = "\n \\brief Get the Output Tensor object\n\n \\param[in] pd_predictor predictor\n \\param[in] name output name\n \\return output tensor\n"]
    pub fn PD_PredictorGetOutputHandle(
        pd_predictor: *mut PD_Predictor,
        name: *const ::std::os::raw::c_char,
    ) -> *mut PD_Tensor;
}
extern "C" {
    #[doc = "\n \\brief Run the prediction engine\n\n \\param[in] pd_predictor predictor\n \\return Whether the function executed successfully\n"]
    pub fn PD_PredictorRun(pd_predictor: *mut PD_Predictor) -> PD_Bool;
}
extern "C" {
    #[doc = " \\brief Clear the intermediate tensors of the predictor\n\n \\param[in] pd_predictor predictor\n"]
    pub fn PD_PredictorClearIntermediateTensor(pd_predictor: *mut PD_Predictor);
}
extern "C" {
    #[doc = "\n \\brief Release all tmp tensor to compress the size of the memory pool.\n The memory pool is considered to be composed of a list of chunks, if\n the chunk is not occupied, it can be released.\n\n \\param[in] pd_predictor predictor\n \\return Number of bytes released. It may be smaller than the actual\n released memory, because part of the memory is not managed by the\n MemoryPool.\n"]
    pub fn PD_PredictorTryShrinkMemory(pd_predictor: *mut PD_Predictor) -> u64;
}
extern "C" {
    #[doc = "\n \\brief Destroy a predictor object\n\n \\param[in] pd_predictor predictor\n"]
    pub fn PD_PredictorDestroy(pd_predictor: *mut PD_Predictor);
}
extern "C" {
    #[doc = "\n \\brief Get version info.\n\n \\return version\n"]
    pub fn PD_GetVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\n \\brief Destroy the paddle tensor\n\n \\param[in] pd_tensor tensor\n"]
    pub fn PD_TensorDestroy(pd_tensor: *mut PD_Tensor);
}
extern "C" {
    #[doc = "\n \\brief Reset the shape of the tensor.\n Generally it's only used for the input tensor.\n Reshape must be called before calling PD_TensorMutableData*() or\n PD_TensorCopyFromCpu*()\n\n \\param[in] pd_tensor tensor.\n \\param[in] shape_size The size of shape.\n \\param[in] shape The shape to set.\n"]
    pub fn PD_TensorReshape(pd_tensor: *mut PD_Tensor, shape_size: usize, shape: *mut i32);
}
extern "C" {
    #[doc = "\n \\brief Get the memory pointer in CPU or GPU with 'float' data type.\n Please Reshape the tensor first before call this.\n It's usually used to get input data pointer.\n\n \\param[in] pd_tensor tensor.\n \\param[in] place The place of the tensor.\n \\return Memory pointer of pd_tensor\n"]
    pub fn PD_TensorMutableDataFloat(pd_tensor: *mut PD_Tensor, place: PD_PlaceType) -> *mut f32;
}
extern "C" {
    #[doc = "\n \\brief Get the memory pointer in CPU or GPU with 'int64_t' data type.\n Please Reshape the tensor first before call this.\n It's usually used to get input data pointer.\n\n \\param[in] pd_tensor tensor.\n \\param[in] place The place of the tensor.\n \\return Memory pointer of pd_tensor\n"]
    pub fn PD_TensorMutableDataInt64(pd_tensor: *mut PD_Tensor, place: PD_PlaceType) -> *mut i64;
}
extern "C" {
    #[doc = "\n \\brief Get the memory pointer in CPU or GPU with 'int32_t' data type.\n Please Reshape the tensor first before call this.\n It's usually used to get input data pointer.\n\n \\param[in] pd_tensor tensor.\n \\param[in] place The place of the tensor.\n \\return Memory pointer of pd_tensor\n"]
    pub fn PD_TensorMutableDataInt32(pd_tensor: *mut PD_Tensor, place: PD_PlaceType) -> *mut i32;
}
extern "C" {
    #[doc = "\n \\brief Get the memory pointer in CPU or GPU with 'uint8_t' data type.\n Please Reshape the tensor first before call this.\n It's usually used to get input data pointer.\n\n \\param[in] pd_tensor tensor.\n \\param[in] place The place of the tensor.\n \\return Memory pointer of pd_tensor\n"]
    pub fn PD_TensorMutableDataUint8(pd_tensor: *mut PD_Tensor, place: PD_PlaceType) -> *mut u8;
}
extern "C" {
    #[doc = "\n \\brief Get the memory pointer in CPU or GPU with 'int8_t' data type.\n Please Reshape the tensor first before call this.\n It's usually used to get input data pointer.\n\n \\param[in] pd_tensor tensor.\n \\param[in] place The place of the tensor.\n \\return Memory pointer of pd_tensor\n"]
    pub fn PD_TensorMutableDataInt8(pd_tensor: *mut PD_Tensor, place: PD_PlaceType) -> *mut i8;
}
extern "C" {
    #[doc = "\n \\brief Get the memory pointer directly.\n It's usually used to get the output data pointer.\n\n \\param[in] pd_tensor tensor.\n \\param[out] place To get the device type of the tensor.\n \\param[out] size To get the data size of the tensor.\n \\return The tensor data buffer pointer.\n"]
    pub fn PD_TensorDataFloat(
        pd_tensor: *mut PD_Tensor,
        place: *mut PD_PlaceType,
        size: *mut i32,
    ) -> *mut f32;
}
extern "C" {
    #[doc = "\n \\brief Get the memory pointer directly.\n It's usually used to get the output data pointer.\n\n \\param[in] pd_tensor tensor.\n \\param[out] place To get the device type of the tensor.\n \\param[out] size To get the data size of the tensor.\n \\return The tensor data buffer pointer.\n"]
    pub fn PD_TensorDataInt64(
        pd_tensor: *mut PD_Tensor,
        place: *mut PD_PlaceType,
        size: *mut i32,
    ) -> *mut i64;
}
extern "C" {
    #[doc = "\n \\brief Get the memory pointer directly.\n It's usually used to get the output data pointer.\n\n \\param[in] pd_tensor tensor.\n \\param[out] place To get the device type of the tensor.\n \\param[out] size To get the data size of the tensor.\n \\return The tensor data buffer pointer.\n"]
    pub fn PD_TensorDataInt32(
        pd_tensor: *mut PD_Tensor,
        place: *mut PD_PlaceType,
        size: *mut i32,
    ) -> *mut i32;
}
extern "C" {
    #[doc = "\n \\brief Get the memory pointer directly.\n It's usually used to get the output data pointer.\n\n \\param[in] pd_tensor tensor.\n \\param[out] place To get the device type of the tensor.\n \\param[out] size To get the data size of the tensor.\n \\return The tensor data buffer pointer.\n"]
    pub fn PD_TensorDataUint8(
        pd_tensor: *mut PD_Tensor,
        place: *mut PD_PlaceType,
        size: *mut i32,
    ) -> *mut u8;
}
extern "C" {
    #[doc = "\n \\brief Get the memory pointer directly.\n It's usually used to get the output data pointer.\n\n \\param[in] pd_tensor tensor.\n \\param[out] place To get the device type of the tensor.\n \\param[out] size To get the data size of the tensor.\n \\return The tensor data buffer pointer.\n"]
    pub fn PD_TensorDataInt8(
        pd_tensor: *mut PD_Tensor,
        place: *mut PD_PlaceType,
        size: *mut i32,
    ) -> *mut i8;
}
extern "C" {
    #[doc = "\n \\brief Copy the host memory to tensor data.\n It's usually used to set the input tensor data.\n \\param[in] pd_tensor tensor.\n \\param[in] data The pointer of the data, from which the tensor will copy.\n"]
    pub fn PD_TensorCopyFromCpuFloat(pd_tensor: *mut PD_Tensor, data: *const f32);
}
extern "C" {
    #[doc = "\n \\brief Copy the host memory to tensor data.\n It's usually used to set the input tensor data.\n \\param[in] pd_tensor tensor.\n \\param[in] data The pointer of the data, from which the tensor will copy.\n"]
    pub fn PD_TensorCopyFromCpuInt64(pd_tensor: *mut PD_Tensor, data: *const i64);
}
extern "C" {
    #[doc = "\n \\brief Copy the host memory to tensor data.\n It's usually used to set the input tensor data.\n \\param[in] pd_tensor tensor.\n \\param[in] data The pointer of the data, from which the tensor will copy.\n"]
    pub fn PD_TensorCopyFromCpuInt32(pd_tensor: *mut PD_Tensor, data: *const i32);
}
extern "C" {
    #[doc = "\n \\brief Copy the host memory to tensor data.\n It's usually used to set the input tensor data.\n \\param[in] pd_tensor tensor.\n \\param[in] data The pointer of the data, from which the tensor will copy.\n"]
    pub fn PD_TensorCopyFromCpuUint8(pd_tensor: *mut PD_Tensor, data: *const u8);
}
extern "C" {
    #[doc = "\n \\brief Copy the host memory to tensor data.\n It's usually used to set the input tensor data.\n \\param[in] pd_tensor tensor.\n \\param[in] data The pointer of the data, from which the tensor will copy.\n"]
    pub fn PD_TensorCopyFromCpuInt8(pd_tensor: *mut PD_Tensor, data: *const i8);
}
extern "C" {
    #[doc = "\n \\brief Copy the tensor data to the host memory.\n It's usually used to get the output tensor data.\n \\param[in] pd_tensor tensor.\n \\param[out] data The tensor will copy the data to the address.\n"]
    pub fn PD_TensorCopyToCpuFloat(pd_tensor: *mut PD_Tensor, data: *mut f32);
}
extern "C" {
    #[doc = "\n \\brief Copy the tensor data to the host memory.\n It's usually used to get the output tensor data.\n \\param[in] pd_tensor tensor.\n \\param[out] data The tensor will copy the data to the address.\n"]
    pub fn PD_TensorCopyToCpuInt64(pd_tensor: *mut PD_Tensor, data: *mut i64);
}
extern "C" {
    #[doc = "\n \\brief Copy the tensor data to the host memory.\n It's usually used to get the output tensor data.\n \\param[in] pd_tensor tensor.\n \\param[out] data The tensor will copy the data to the address.\n"]
    pub fn PD_TensorCopyToCpuInt32(pd_tensor: *mut PD_Tensor, data: *mut i32);
}
extern "C" {
    #[doc = "\n \\brief Copy the tensor data to the host memory.\n It's usually used to get the output tensor data.\n \\param[in] pd_tensor tensor.\n \\param[out] data The tensor will copy the data to the address.\n"]
    pub fn PD_TensorCopyToCpuUint8(pd_tensor: *mut PD_Tensor, data: *mut u8);
}
extern "C" {
    #[doc = "\n \\brief Copy the tensor data to the host memory.\n It's usually used to get the output tensor data.\n \\param[in] pd_tensor tensor.\n \\param[out] data The tensor will copy the data to the address.\n"]
    pub fn PD_TensorCopyToCpuInt8(pd_tensor: *mut PD_Tensor, data: *mut i8);
}
extern "C" {
    #[doc = "\n \\brief Get the tensor shape\n \\param[in] pd_tensor tensor.\n \\return The tensor shape.\n"]
    pub fn PD_TensorGetShape(pd_tensor: *mut PD_Tensor) -> *mut PD_OneDimArrayInt32;
}
extern "C" {
    #[doc = "\n \\brief Set the tensor lod information\n \\param[in] pd_tensor tensor.\n \\param[in] lod lod information.\n"]
    pub fn PD_TensorSetLod(pd_tensor: *mut PD_Tensor, lod: *mut PD_TwoDimArraySize);
}
extern "C" {
    #[doc = "\n \\brief Get the tensor lod information\n \\param[in] pd_tensor tensor.\n \\return the lod information.\n"]
    pub fn PD_TensorGetLod(pd_tensor: *mut PD_Tensor) -> *mut PD_TwoDimArraySize;
}
extern "C" {
    #[doc = "\n \\brief Get the tensor name\n \\param[in] pd_tensor tensor.\n \\return the tensor name.\n"]
    pub fn PD_TensorGetName(pd_tensor: *mut PD_Tensor) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\n \\brief Get the tensor data type\n \\param[in] pd_tensor tensor.\n \\return the tensor data type.\n"]
    pub fn PD_TensorGetDataType(pd_tensor: *mut PD_Tensor) -> PD_DataType;
}
extern "C" {
    #[doc = "\n \\brief Destroy the PD_OneDimArrayInt32 object pointed to by the pointer.\n\n \\param[in] array pointer to the PD_OneDimArrayInt32 object.\n"]
    pub fn PD_OneDimArrayInt32Destroy(array: *mut PD_OneDimArrayInt32);
}
extern "C" {
    #[doc = "\n \\brief Destroy the PD_OneDimArrayCstr object pointed to by the pointer.\n\n \\param[in] array pointer to the PD_OneDimArrayCstr object.\n"]
    pub fn PD_OneDimArrayCstrDestroy(array: *mut PD_OneDimArrayCstr);
}
extern "C" {
    #[doc = "\n \\brief Destroy the PD_OneDimArraySize object pointed to by the pointer.\n\n \\param[in] array pointer to the PD_OneDimArraySize object.\n"]
    pub fn PD_OneDimArraySizeDestroy(array: *mut PD_OneDimArraySize);
}
extern "C" {
    #[doc = "\n \\brief Destroy the PD_TwoDimArraySize object pointed to by the pointer.\n\n \\param[in] array pointer to the PD_TwoDimArraySize object.\n"]
    pub fn PD_TwoDimArraySizeDestroy(array: *mut PD_TwoDimArraySize);
}
extern "C" {
    #[doc = "\n \\brief Destroy the PD_Cstr object pointed to by the pointer.\n NOTE: if input string is empty, the return PD_Cstr's size is\n 0 and data is NULL.\n\n \\param[in] cstr pointer to the PD_Cstr object.\n"]
    pub fn PD_CstrDestroy(cstr: *mut PD_Cstr);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
